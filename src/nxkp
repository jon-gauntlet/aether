#!/usr/bin/env python3

"""
Meta-Learner Service
Supports the Essence System Harmonizer with pattern learning and optimization
"""

import argparse
import json
import logging
import os
import sys
import time
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Union

# Environment setup
CURSOR_CONFIG_DIR = os.getenv('CURSOR_CONFIG_DIR', os.path.expanduser('~/.config/cursor'))
CURSOR_DATA_DIR = os.getenv('CURSOR_DATA_DIR', os.path.expanduser('~/.local/share/cursor'))
BRAIN_DIR = os.getenv('BRAIN_DIR', os.path.expanduser('~/brain'))

# Core paths
PATTERN_DB = Path(CURSOR_DATA_DIR) / 'autonomic' / 'patterns' / 'pattern_database.json'
CONTEXT_DIR = Path(CURSOR_DATA_DIR) / 'contexts'
SESSION_DIR = Path(CURSOR_DATA_DIR) / 'crystallized'
META_STATE = Path(CURSOR_DATA_DIR) / 'meta' / 'state.json'

# Knowledge paths
KNOWLEDGE_MAP = Path(BRAIN_DIR) / 'KNOWLEDGE_MAP.md'
AUTONOMIC_MAP = Path(BRAIN_DIR) / 'autonomic' / 'AUTONOMIC_MAP.md'
SACRED_MAP = Path(BRAIN_DIR) / 'sacred' / 'SACRED_MAP.md'

# Ensure directories exist
for path in [PATTERN_DB.parent, CONTEXT_DIR, SESSION_DIR, META_STATE.parent]:
    path.mkdir(parents=True, exist_ok=True)

# Logging setup
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler(SESSION_DIR / 'meta-learner.log'),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger('meta-learner')

class MetaLearner:
    def __init__(self):
        self.patterns: Dict = self._load_patterns()
        self.state: Dict = self._load_state()
        
    def _load_patterns(self) -> Dict:
        """Load pattern database."""
        if PATTERN_DB.exists():
            with open(PATTERN_DB) as f:
                return json.load(f)
        return {}
    
    def _save_patterns(self):
        """Save pattern database."""
        with open(PATTERN_DB, 'w') as f:
            json.dump(self.patterns, f, indent=2)
            
    def _load_state(self) -> Dict:
        """Load meta-learner state."""
        if META_STATE.exists():
            with open(META_STATE) as f:
                return json.load(f)
        return {
            'last_sync': None,
            'flow_state': 'standard',
            'protection_level': 'normal',
            'balance_metrics': {}
        }
    
    def _save_state(self):
        """Save meta-learner state."""
        with open(META_STATE, 'w') as f:
            json.dump(self.state, f, indent=2)
    
    def update_pattern(self, pattern: str):
        """Update pattern in database."""
        timestamp = datetime.now().isoformat()
        
        if pattern not in self.patterns:
            self.patterns[pattern] = {
                'first_seen': timestamp,
                'last_seen': timestamp,
                'count': 1,
                'contexts': []
            }
        else:
            self.patterns[pattern]['last_seen'] = timestamp
            self.patterns[pattern]['count'] += 1
            
        self._save_patterns()
        logger.info(f'Updated pattern: {pattern}')
        
    def protect_flow(self, level: str):
        """Set flow protection level."""
        valid_levels = ['flow', 'standard', 'minimal', 'recovery']
        if level not in valid_levels:
            raise ValueError(f'Invalid protection level. Must be one of: {valid_levels}')
            
        self.state['flow_state'] = level
        self.state['protection_level'] = {
            'flow': 'maximum',
            'standard': 'normal',
            'minimal': 'basic',
            'recovery': 'minimal'
        }[level]
        
        self._save_state()
        logger.info(f'Set flow protection to: {level}')
        
    def sync_knowledge(self):
        """Synchronize knowledge maps."""
        timestamp = datetime.now().isoformat()
        
        # Verify knowledge maps exist
        maps = [KNOWLEDGE_MAP, AUTONOMIC_MAP, SACRED_MAP]
        for map_path in maps:
            if not map_path.exists():
                logger.warning(f'Missing knowledge map: {map_path}')
                continue
                
        self.state['last_sync'] = timestamp
        self._save_state()
        logger.info('Knowledge synchronized')
        
    def balance_system(self, aspect: str):
        """Balance system aspect."""
        timestamp = datetime.now().isoformat()
        
        metrics = self.state.get('balance_metrics', {})
        metrics[aspect] = {
            'last_balanced': timestamp,
            'status': 'balanced'
        }
        
        self.state['balance_metrics'] = metrics
        self._save_state()
        logger.info(f'Balanced system aspect: {aspect}')
        
    def suggest_break(self):
        """Suggest taking a break based on system state."""
        current_time = datetime.now()
        last_break = self.state.get('last_break')
        
        if last_break:
            last_break = datetime.fromisoformat(last_break)
            hours_since_break = (current_time - last_break).total_seconds() / 3600
            
            if hours_since_break > 2:
                logger.info('Break suggested: More than 2 hours since last break')
                return True
                
        self.state['last_break'] = current_time.isoformat()
        self._save_state()
        return False

def main():
    parser = argparse.ArgumentParser(description='Meta-Learner Service')
    parser.add_argument('--update-pattern', help='Update pattern in database')
    parser.add_argument('--protect', help='Set flow protection level')
    parser.add_argument('--sync-knowledge', action='store_true', help='Synchronize knowledge maps')
    parser.add_argument('--balance', help='Balance system aspect')
    parser.add_argument('--suggest-break', action='store_true', help='Suggest taking a break')
    
    args = parser.parse_args()
    learner = MetaLearner()
    
    try:
        if args.update_pattern:
            learner.update_pattern(args.update_pattern)
        elif args.protect:
            learner.protect_flow(args.protect)
        elif args.sync_knowledge:
            learner.sync_knowledge()
        elif args.balance:
            learner.balance_system(args.balance)
        elif args.suggest_break:
            should_break = learner.suggest_break()
            sys.exit(0 if not should_break else 1)
    except Exception as e:
        logger.error(f'Error: {str(e)}')
        sys.exit(1)

if __name__ == '__main__':
    main() 