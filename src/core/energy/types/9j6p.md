# Natural Data Flow Schema

## Core Tables

### Spaces
```sql
CREATE TABLE spaces (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name TEXT NOT NULL,
    energy FLOAT NOT NULL DEFAULT 1.0,
    depth FLOAT NOT NULL DEFAULT 0.0,
    flow_direction VECTOR(3),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Natural indexing
CREATE INDEX idx_spaces_energy ON spaces USING btree (energy);
CREATE INDEX idx_spaces_depth ON spaces USING btree (depth);
```

### Flows
```sql
CREATE TABLE flows (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    source_id UUID REFERENCES spaces(id),
    target_id UUID REFERENCES spaces(id),
    strength FLOAT NOT NULL DEFAULT 0.0,
    quality FLOAT NOT NULL DEFAULT 1.0,
    type TEXT NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Natural connections
CREATE INDEX idx_flows_strength ON flows USING btree (strength);
CREATE INDEX idx_flows_source_target ON flows (source_id, target_id);
```

### Presence
```sql
CREATE TABLE presence (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    space_id UUID REFERENCES spaces(id),
    user_id UUID REFERENCES users(id),
    energy FLOAT NOT NULL DEFAULT 1.0,
    depth FLOAT NOT NULL DEFAULT 0.0,
    state JSONB NOT NULL DEFAULT '{}',
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Natural awareness
CREATE INDEX idx_presence_space ON presence (space_id);
CREATE INDEX idx_presence_user ON presence (user_id);
```

## Natural Flows

### Messages
```sql
CREATE TABLE messages (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    space_id UUID REFERENCES spaces(id),
    sender_id UUID REFERENCES users(id),
    content TEXT NOT NULL,
    energy FLOAT NOT NULL DEFAULT 1.0,
    depth FLOAT NOT NULL DEFAULT 0.0,
    flow_path JSONB NOT NULL DEFAULT '[]',
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Natural discovery
CREATE INDEX idx_messages_space_time ON messages (space_id, created_at);
CREATE INDEX idx_messages_energy ON messages USING btree (energy);
```

### Connections
```sql
CREATE TABLE connections (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    source_type TEXT NOT NULL,
    source_id UUID NOT NULL,
    target_type TEXT NOT NULL,
    target_id UUID NOT NULL,
    strength FLOAT NOT NULL DEFAULT 0.0,
    nature TEXT NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Natural pathways
CREATE INDEX idx_connections_source ON connections (source_type, source_id);
CREATE INDEX idx_connections_target ON connections (target_type, target_id);
```

## Flow Patterns

### Activities
```sql
CREATE TABLE activities (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    space_id UUID REFERENCES spaces(id),
    user_id UUID REFERENCES users(id),
    type TEXT NOT NULL,
    energy FLOAT NOT NULL DEFAULT 1.0,
    depth FLOAT NOT NULL DEFAULT 0.0,
    context JSONB NOT NULL DEFAULT '{}',
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Natural tracking
CREATE INDEX idx_activities_space_time ON activities (space_id, created_at);
CREATE INDEX idx_activities_user_time ON activities (user_id, created_at);
```

### States
```sql
CREATE TABLE states (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    entity_type TEXT NOT NULL,
    entity_id UUID NOT NULL,
    name TEXT NOT NULL,
    value JSONB NOT NULL,
    energy FLOAT NOT NULL DEFAULT 1.0,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Natural state tracking
CREATE INDEX idx_states_entity ON states (entity_type, entity_id);
CREATE INDEX idx_states_name ON states (name);
```

## Natural Functions

### Flow Calculation
```sql
CREATE OR REPLACE FUNCTION calculate_flow(
    source_energy FLOAT,
    target_energy FLOAT,
    distance FLOAT
) RETURNS FLOAT AS $$
BEGIN
    RETURN (source_energy * target_energy) / (distance * distance);
END;
$$ LANGUAGE plpgsql;
```

### Energy Distribution
```sql
CREATE OR REPLACE FUNCTION distribute_energy(
    space_id UUID,
    new_energy FLOAT
) RETURNS VOID AS $$
BEGIN
    -- Energy naturally flows to connected spaces
    UPDATE spaces
    SET energy = energy + (new_energy * 0.1)
    WHERE id IN (
        SELECT target_id
        FROM flows
        WHERE source_id = space_id
    );
END;
$$ LANGUAGE plpgsql;
```

### Depth Measurement
```sql
CREATE OR REPLACE FUNCTION measure_depth(
    space_id UUID
) RETURNS FLOAT AS $$
DECLARE
    avg_depth FLOAT;
BEGIN
    SELECT AVG(depth)
    INTO avg_depth
    FROM presence
    WHERE space_id = space_id;
    
    RETURN COALESCE(avg_depth, 0.0);
END;
$$ LANGUAGE plpgsql;
```

## Natural Triggers

### Space Energy Flow
```sql
CREATE OR REPLACE FUNCTION flow_energy() RETURNS TRIGGER AS $$
BEGIN
    -- Energy naturally flows when spaces change
    IF NEW.energy <> OLD.energy THEN
        PERFORM distribute_energy(NEW.id, NEW.energy - OLD.energy);
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER space_energy_flow
AFTER UPDATE ON spaces
FOR EACH ROW
WHEN (NEW.energy IS DISTINCT FROM OLD.energy)
EXECUTE FUNCTION flow_energy();
```

### Connection Strength
```sql
CREATE OR REPLACE FUNCTION strengthen_connection() RETURNS TRIGGER AS $$
BEGIN
    -- Connections naturally strengthen with use
    UPDATE connections
    SET strength = LEAST(strength + 0.1, 1.0)
    WHERE id = NEW.id;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER connection_strengthen
AFTER INSERT ON activities
FOR EACH ROW
EXECUTE FUNCTION strengthen_connection();
```

Remember: Data should flow as naturally as the experiences it supports. 